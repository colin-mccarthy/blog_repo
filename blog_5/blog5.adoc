= {subject} [black]*Ansible For Network Engineers*
TheNetwork.Engineer
:subject:
:description:
:doctype:
:confidentiality:
:listing-caption: Listing
:toc:
:toclevels: 6
:sectnums:
:chapter-label:
:icons: font
ifdef::backend-pdf[]
:pdf-page-size: A4
:source-highlighter: rouge
:rouge-style: github
endif::[]




image:images/ansible.jpg[]


[red big]*Using pyATS and Genie with Ansible*

Cisco has released two Python3 libraries that are very useful for network automation. This blog will cover
using the parsers that are made available in the Genie library. We will do that by calling a role in our playbook by the name parse_genie

The role can be found https://galaxy.ansible.com/clay584/parse_genie[here] on Galaxy.

This role was graciously created by Clay Curtis @ccurtis584

This plugin will require Python 3.4+ and you need to pip install the pyATS and Genie.


pyATS Genie v19.5 has been released with 60 new parsers supporting IOS/IOSXE/XR/NXOS!
It contains 1129 full parsers listed here...
https://pubhub.devnetcloud.com/media/pyats-packages/docs/genie/genie_libs/#/parsers


Let me show you my idea of how this role would be used.

We need to evoke the role at the beginning of the playbook so we
can use the filter plugin in a later play.

We then need to execute show command and register the output to a variable.

We can then run the text obtained via out show command through the filter plugin, it will then return to us structured data in JSON.
We now can programmatically use our parsed data very easily.




[source,yaml]
----
---
- name: pyats testing
  hosts: ios
  gather_facts: no
  connection: network_cli
  roles:
    - parse_genie

  tasks:

  - name: show interfaces
    ios_command:
      commands:
        - show interfaces
    register: interfaces

  - name: Set Fact Genie Filter
    set_fact:
      pyats_interfaces: "{{ interfaces['stdout'][0] | parse_genie(command='show interfaces', os='ios') }}"

  - name: Debug Pyats facts
    debug:
     var: pyats_interfaces
----


image:images/asciicinema.gif[]


[black big]*Data Model*

While I developed this role on my own I still wanted to hold myself to using Git collaboration best practices. I used the GitFlow workflow for
all changes to the code. I created a [red]#devel# branch and worked in there for all my testing and additions to the codebase. Once I had something
new or a bug fix figured out and was happy with it, I created a Pull request against the [red]#master# branch. If you ever have a chance to contribute to
the open-source Ansible project on GitHub you will follow the same process of forking and creating pull requests.

Learning this flow is the most important things you can do to embrace and benefit from these developer tools our field is moving towards adopting.
When you are working on a code project with other people who are also contributing this flow becomes imperative.
Learn this before worrying about Travis CI, hooks, or anything else.




[black big]*Stay tuned for more blogs*




|===
|===


|===

|===
TheNetwork.Engineer - June 16 2019  -  Colin McCarthy
|===
